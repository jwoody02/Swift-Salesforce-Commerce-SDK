//
// PasswordActionRequest.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** A request for a password reset token. This is only available for resgistered users using ECOM. */
public struct PasswordActionRequest: Codable, JSONEncodable, Hashable {

    static let userIdRule = StringRule(minLength: nil, maxLength: 128, pattern: nil)
    static let clientIdRule = StringRule(minLength: nil, maxLength: 40, pattern: nil)
    static let codeChallengeRule = StringRule(minLength: 43, maxLength: 128, pattern: nil)
    /** User ID for logging in. This is the id that is used to log into SFCC. */
    public var userId: String
    public var mode: PasswordActionModes
    /** The channel (ECOM site) that the user is associated with. */
    public var channelId: String
    /** The locale of the template. */
    public var locale: String?
    /** The public client ID. Requires setting `grant_type` to `passwordless_login_pkce` */
    public var clientId: String?
    /** PKCE code challenge. Created by the client.  The `code_challenge` is created by SHA256 hashing the `code_verifier` and Base64 encoding the resulting hash.  The `code_verifier` should be a high entropy cryptographically random string with a minimum of 43 characters and a maximum of 128 characters.    Requires setting `grant_type` to `passwordless_login_pkce` */
    public var codeChallenge: String?
    /** The callback uri. Required when the mode is `callback`. The `callback_uri` property will be validated against the callback URIs that have been registered with the SLAS client. The callback URI _must_ be a `POST` endpoint because the token will be included in the body.  Wildcards are not allowed in the callback_uri because this is a security risk that can expose the token. This is not considered an OAuth2 callback_url.  */
    public var callbackUri: String?
    /** The name of the 3rd party identity provider for the user ID */
    public var idpName: String?

    public init(userId: String, mode: PasswordActionModes, channelId: String, locale: String? = nil, clientId: String? = nil, codeChallenge: String? = nil, callbackUri: String? = nil, idpName: String? = nil) {
        self.userId = userId
        self.mode = mode
        self.channelId = channelId
        self.locale = locale
        self.clientId = clientId
        self.codeChallenge = codeChallenge
        self.callbackUri = callbackUri
        self.idpName = idpName
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case userId = "user_id"
        case mode
        case channelId = "channel_id"
        case locale
        case clientId = "client_id"
        case codeChallenge = "code_challenge"
        case callbackUri = "callback_uri"
        case idpName = "idp_name"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(userId, forKey: .userId)
        try container.encode(mode, forKey: .mode)
        try container.encode(channelId, forKey: .channelId)
        try container.encodeIfPresent(locale, forKey: .locale)
        try container.encodeIfPresent(clientId, forKey: .clientId)
        try container.encodeIfPresent(codeChallenge, forKey: .codeChallenge)
        try container.encodeIfPresent(callbackUri, forKey: .callbackUri)
        try container.encodeIfPresent(idpName, forKey: .idpName)
    }
}

