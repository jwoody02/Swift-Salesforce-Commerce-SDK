//
// TrustedSystemTokenRequest.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** A request for an access token on behalf of a registered user whose credentials are stored using a third party system. */
public struct TrustedSystemTokenRequest: Codable, JSONEncodable, Hashable {

    static let loginIdRule = StringRule(minLength: nil, maxLength: 128, pattern: nil)
    static let clientIdRule = StringRule(minLength: nil, maxLength: 40, pattern: nil)
    static let channelIdRule = StringRule(minLength: nil, maxLength: 100, pattern: nil)
    static let emailIdRule = StringRule(minLength: nil, maxLength: 128, pattern: nil)
    /** The shopper's unique identifier, if known. If not provided, a new USID is generated. */
    public var usid: String?
    public var grantType: GrantType
    public var hint: TrustedOnBehalf
    /** The ID used by the shopper for trusted system access.   If set to `guest`, a token is returned for a guest user. */
    public var loginId: String
    public var idpOrigin: ThirdPartyIdps
    /** The SLAS public client ID for use with internal trusted-system requests. */
    public var clientId: String
    /** The channel (ECOM site) that the user is associated with. */
    public var channelId: String
    /** The email address for the shopper that is used for trusted-system requests. If not provided, `login_id` is used instead. */
    public var emailId: String?

    public init(usid: String? = nil, grantType: GrantType, hint: TrustedOnBehalf, loginId: String, idpOrigin: ThirdPartyIdps, clientId: String, channelId: String, emailId: String? = nil) {
        self.usid = usid
        self.grantType = grantType
        self.hint = hint
        self.loginId = loginId
        self.idpOrigin = idpOrigin
        self.clientId = clientId
        self.channelId = channelId
        self.emailId = emailId
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case usid
        case grantType = "grant_type"
        case hint
        case loginId = "login_id"
        case idpOrigin = "idp_origin"
        case clientId = "client_id"
        case channelId = "channel_id"
        case emailId = "email_id"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(usid, forKey: .usid)
        try container.encode(grantType, forKey: .grantType)
        try container.encode(hint, forKey: .hint)
        try container.encode(loginId, forKey: .loginId)
        try container.encode(idpOrigin, forKey: .idpOrigin)
        try container.encode(clientId, forKey: .clientId)
        try container.encode(channelId, forKey: .channelId)
        try container.encodeIfPresent(emailId, forKey: .emailId)
    }
}

